"""
Master Hybrid Amsterdam Model v2
Comprehensive Food Systems Scope 3 Emissions Analysis

This version provides advanced multi-chart visualization and spatial analysis:
- 7 diet scenarios with behavioral modifiers (income + education)
- Comprehensive visualization suite (nexus, plates, donuts, heatmap)
- Distance-to-goals matrix showing required emission reductions
- Neighborhood hotspot analysis with income scaling
- Multi-dimensional impact assessment (CO2, land, water)

New Features in v2:
- Education-based behavioral modifiers (high education = lower meat preference)
- Distance-to-goals heatmap (% reduction needed to reach targets)
- Separated mass vs emissions visualizations
- Side-by-side donuts showing category breakdown and total emissions

Outputs:
- 1_Nexus_Analysis.png: Multi-resource impact comparison
- 2_All_Plates_Mass.png: Physical diet composition comparison
- 3_All_Emissions_Donuts.png: Emission sources breakdown
- 4_Distance_To_Goals.png: Heatmap of reduction pathways
- 5_Neighborhood_Hotspots.png: Spatial emission distribution
- Console: Master tonnage report with baseline comparison

Author: Challenge Based Project Team
Date: January 2026
Version: 2.0
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# ==========================================
# 1. CONFIGURATION
# ==========================================
class HybridModelConfig:
    """
    Configuration parameters for the hybrid food systems model v2.
    
    Attributes:
        NATIONAL_AVG_INCOME (int): Netherlands average household income (EUR/year)
        SCALING_C1 (float): Valencia volume scaling coefficient
        SCALING_C2 (float): Valencia income elasticity exponent
        WASTE_FACTOR (float): Supply chain loss multiplier (1.15 = 15% waste)
        POPULATION_TOTAL (int): Total Amsterdam metropolitan population
    """
    
    def __init__(self):
        self.NATIONAL_AVG_INCOME = 32000
        self.SCALING_C1 = 0.8
        self.SCALING_C2 = 0.2
        self.WASTE_FACTOR = 1.15   # Supply chain loss
        self.POPULATION_TOTAL = 882000

# --- VISUALIZATION MAPPING ---
# Consolidates granular model keys into 9 Report Categories (added Beverages & Additions)
# Maps individual food items (e.g., Beef, Pork) to broader food groups (e.g., Red Meat)
VISUAL_MAPPING = {
    'Beef': 'Red Meat', 'Pork': 'Red Meat',
    'Chicken': 'Poultry', 'Poultry': 'Poultry',
    'Cheese': 'Dairy & Eggs', 'Milk': 'Dairy & Eggs', 'Eggs': 'Dairy & Eggs', 'Dairy': 'Dairy & Eggs',
    'Fish': 'Fish',
    'Pulses': 'Plant Protein', 'Nuts': 'Plant Protein', 'Meat_Subs': 'Plant Protein', 'Plant Protein': 'Plant Protein',
    'Grains': 'Staples', 'Potatoes': 'Staples', 'Staples': 'Staples',
    'Vegetables': 'Veg & Fruit', 'Fruits': 'Veg & Fruit', 'Veg & Fruit': 'Veg & Fruit',
    'Sugar': 'Ultra-Processed', 'Processed': 'Ultra-Processed', 'Ultra-Processed': 'Ultra-Processed', 'Snacks': 'Ultra-Processed',
    'Coffee': 'Beverages & Additions', 'Tea': 'Beverages & Additions', 'Alcohol': 'Beverages & Additions',
    'Oils': 'Oils & Condiments', 'Condiments': 'Oils & Condiments'
}

# --- COLOR PALETTE ---
# Consistent category ordering for all visualizations (9 categories + Beverages + Oils)
CAT_ORDER = ['Red Meat', 'Poultry', 'Dairy & Eggs', 'Fish', 'Plant Protein', 'Staples', 'Veg & Fruit', 'Ultra-Processed', 'Beverages & Additions', 'Oils & Condiments']

# Color scheme: gradient from high-impact (dark red) to low-impact (light green)
COLORS = ['#8B0000', '#F08080', '#FFD700', '#4682B4', '#2E8B57', '#DEB887', '#90EE90', '#A9A9A9', '#8B4513', '#DAA520']

# Color mapping dictionary for easy lookup in plots
COLOR_MAP = dict(zip(CAT_ORDER, COLORS))

# ==========================================
# 2. DATA INGESTION
# ==========================================
def load_impact_factors():
    """ 
    Load comprehensive Scope 3 environmental impact factors.
    
    Data sources:
    - CO2 factors: Trans-boundary LCA from Blonk Consultants
    - Land use: Global agricultural land footprint (Poore & Nemecek 2018)
    - Water: Blue water consumption (WaterFootprint Network)
    
    Returns:
        pd.DataFrame: Impact factors indexed by food item with columns:
            - co2: kg CO2e per kg product
            - land: m² per kg product
            - water: liters per kg product
    """
    # FULL FOOD SYSTEM Scope 1+2 factors (kgCO2e/kg consumed) - CALIBRATED TO 1750 KTON
    # Base food emissions (1542 kton) + Waste 11% (170 kton) + Retail 2.5% (39 kton) = 1751 kton
    # Includes: Production + Retail + Food Service + Household (cooking/refrigeration)
    # Waste and retail/distribution emissions added separately in calculation
    factors = {
        # PROTEINS
        'Beef':      {'co2': 28.0, 'land': 25.0, 'water': 15400, 'scope12': 16.67},
        'Pork':      {'co2': 5.0,  'land': 9.0,  'water': 6000,  'scope12': 13.34},
        'Chicken':   {'co2': 3.5,  'land': 7.0,  'water': 4300,  'scope12': 10.00},
        'Cheese':    {'co2': 10.0, 'land': 12.0, 'water': 5000,  'scope12': 6.67},
        'Milk':      {'co2': 1.3,  'land': 1.5,  'water': 1000,  'scope12': 3.33},
        'Fish':      {'co2': 3.5,  'land': 0.5,  'water': 2000,  'scope12': 12.00},
        'Eggs':      {'co2': 2.2,  'land': 2.5,  'water': 3300,  'scope12': 5.34},
        'Pulses':    {'co2': 0.9,  'land': 3.0,  'water': 4000,  'scope12': 2.67},
        'Nuts':      {'co2': 0.3,  'land': 2.5,  'water': 9000,  'scope12': 1.33},
        'Meat_Subs': {'co2': 2.5,  'land': 3.0,  'water': 200,   'scope12': 3.33},
        
        # STAPLES & BASE FOODS
        'Grains':    {'co2': 1.1,  'land': 1.8,  'water': 1600,  'scope12': 1.67},
        'Vegetables':{'co2': 0.6,  'land': 0.5,  'water': 320,   'scope12': 1.33},
        'Fruits':    {'co2': 0.7,  'land': 0.6,  'water': 960,   'scope12': 1.33},
        'Potatoes':  {'co2': 0.4,  'land': 0.3,  'water': 290,   'scope12': 1.33},
        'Sugar':     {'co2': 2.0,  'land': 1.5,  'water': 200,   'scope12': 1.33},
        'Processed': {'co2': 2.5,  'land': 1.5,  'water': 300,   'scope12': 3.33},
        
        # BEVERAGES & ADDITIONS (explicit categories, not in blanket multiplier)
        'Coffee':    {'co2': 15.0, 'land': 10.0, 'water': 18900, 'scope12': 23.34},
        'Tea':       {'co2': 5.0,  'land': 3.0,  'water': 8900,  'scope12': 8.00},
        'Alcohol':   {'co2': 2.5,  'land': 2.0,  'water': 2500,  'scope12': 13.34},
        'Oils':      {'co2': 3.5,  'land': 5.0,  'water': 4200,  'scope12': 5.34},
        'Snacks':    {'co2': 3.0,  'land': 2.0,  'water': 500,   'scope12': 10.00},
        'Condiments':{'co2': 1.5,  'land': 1.0,  'water': 800,   'scope12': 4.00}
    }
    return pd.DataFrame.from_dict(factors, orient='index')

def load_diet_profiles():
    """ 
    Load 7 dietary scenario profiles for comprehensive comparison.
    
    Diet Scenarios:
    1. Monitor 2024 (Current): Empirical data from Amsterdam Food Monitor 2024
       - 48% plant protein / 52% animal protein
       - Reflects actual consumption patterns with higher plant-based uptake
       - Lower meat than national average (-20%)
       
    2. Amsterdam Theoretical: Pre-Monitor baseline estimate
       
    3. Metropolitan (High Risk): Western high-meat diet
       - High red meat, processed foods, low vegetables
       - Represents unhealthy urban consumption pattern
       
    4. Metabolic Balance: Animal-based low-carb diet
       - High meat/fish/eggs, minimal grains
       - Keto/paleo style consumption
       
    5. Dutch Goal (60:40): National protein transition target
       - 60% plant protein, 40% animal protein
       
    6. Amsterdam Goal (70:30): City protein transition target
       - 70% plant protein, 30% animal protein
       
    7. EAT-Lancet (Planetary): Global sustainability benchmark
       - Planetary health diet for 10 billion people
    
    Returns:
        dict: Dictionary mapping diet names to consumption profiles (grams/day)
    """
    diets = {
        # --- CURRENT STATES (BASELINES) ---
        '1. Monitor 2024 (Current)': {
            'Beef': 10, 'Pork': 15, 'Chicken': 25, 'Cheese': 35, 'Milk': 220, 
            'Fish': 22, 'Eggs': 28, 'Pulses': 15, 'Nuts': 15, 'Meat_Subs': 20, 
            'Grains': 230, 'Vegetables': 160, 'Fruits': 145, 'Potatoes': 45,
            'Sugar': 35, 'Processed': 140,
            'Coffee': 12, 'Tea': 3, 'Alcohol': 25, 'Oils': 25, 'Snacks': 45, 'Condiments': 20
        },
        '2. Amsterdam Theoretical': {
            'Beef': 12, 'Pork': 20, 'Chicken': 28, 'Cheese': 40, 'Milk': 260,
            'Fish': 10, 'Eggs': 25, 'Pulses': 8, 'Nuts': 10, 'Meat_Subs': 15,
            'Grains': 220, 'Vegetables': 150, 'Fruits': 130, 'Potatoes': 50,
            'Sugar': 40, 'Processed': 60,
            'Coffee': 15, 'Tea': 2, 'Alcohol': 30, 'Oils': 28, 'Snacks': 50, 'Condiments': 22
        },
        '3. Metropolitan (High Risk)': {
            'Beef': 45, 'Pork': 25, 'Chicken': 60, 'Cheese': 50, 'Milk': 200,
            'Fish': 15, 'Eggs': 30, 'Pulses': 5, 'Nuts': 5, 'Meat_Subs': 5,
            'Grains': 180, 'Vegetables': 110, 'Fruits': 100, 'Potatoes': 80,
            'Sugar': 80, 'Processed': 200,
            'Coffee': 18, 'Tea': 1, 'Alcohol': 40, 'Oils': 35, 'Snacks': 80, 'Condiments': 25
        },
        '4. Metabolic Balance': {
            'Beef': 60, 'Pork': 40, 'Chicken': 80, 'Cheese': 50, 'Milk': 50,
            'Fish': 40, 'Eggs': 50, 'Pulses': 10, 'Nuts': 20, 'Meat_Subs': 0,
            'Grains': 50, 'Vegetables': 200, 'Fruits': 100, 'Potatoes': 0,
            'Sugar': 5, 'Processed': 10,
            'Coffee': 10, 'Tea': 2, 'Alcohol': 15, 'Oils': 40, 'Snacks': 10, 'Condiments': 15
        },
        # --- GOAL STATES ---
        '5. Dutch Goal (60:40)': {
            'Beef': 15, 'Pork': 15, 'Chicken': 25, 'Cheese': 35, 'Milk': 250,
            'Fish': 15, 'Eggs': 20, 'Pulses': 40, 'Nuts': 20, 'Meat_Subs': 25,
            'Grains': 225, 'Vegetables': 200, 'Fruits': 180, 'Potatoes': 90,
            'Sugar': 30, 'Processed': 80,
            'Coffee': 10, 'Tea': 4, 'Alcohol': 20, 'Oils': 22, 'Snacks': 35, 'Condiments': 18
        },
        '6. Amsterdam Goal (70:30)': {
            'Beef': 5, 'Pork': 5, 'Chicken': 10, 'Cheese': 20, 'Milk': 100,
            'Fish': 15, 'Eggs': 15, 'Pulses': 80, 'Nuts': 40, 'Meat_Subs': 40,
            'Grains': 250, 'Vegetables': 250, 'Fruits': 200, 'Potatoes': 80,
            'Sugar': 20, 'Processed': 50,
            'Coffee': 8, 'Tea': 5, 'Alcohol': 15, 'Oils': 20, 'Snacks': 20, 'Condiments': 15
        },
        '7. EAT-Lancet (Planetary)': {
            'Beef': 7, 'Pork': 7, 'Chicken': 29, 'Cheese': 0, 'Milk': 250,
            'Fish': 28, 'Eggs': 13, 'Pulses': 75, 'Nuts': 50, 'Meat_Subs': 0,
            'Grains': 232, 'Vegetables': 300, 'Fruits': 200, 'Potatoes': 50,
            'Sugar': 30, 'Processed': 0,
            'Coffee': 6, 'Tea': 6, 'Alcohol': 10, 'Oils': 18, 'Snacks': 10, 'Condiments': 12
        },
        '8. Schijf van 5 (Guideline)': {
            'Beef': 10, 'Pork': 10, 'Chicken': 25, 'Cheese': 30, 'Milk': 250,
            'Fish': 25, 'Eggs': 20, 'Pulses': 30, 'Nuts': 25, 'Meat_Subs': 20,
            'Grains': 240, 'Vegetables': 250, 'Fruits': 200, 'Potatoes': 70,
            'Sugar': 25, 'Processed': 60,
            'Coffee': 9, 'Tea': 5, 'Alcohol': 18, 'Oils': 22, 'Snacks': 25, 'Condiments': 18
        },
        '9. Mediterranean Diet': {
            'Beef': 8, 'Pork': 8, 'Chicken': 20, 'Cheese': 30, 'Milk': 200,
            'Fish': 35, 'Eggs': 18, 'Pulses': 60, 'Nuts': 30, 'Meat_Subs': 10,
            'Grains': 240, 'Vegetables': 300, 'Fruits': 220, 'Potatoes': 60,
            'Sugar': 20, 'Processed': 50,
            'Coffee': 8, 'Tea': 6, 'Alcohol': 15, 'Oils': 25, 'Snacks': 20, 'Condiments': 15
        }
    }
    return diets

def load_neighborhood_data():
    """ 
    Load Amsterdam neighborhood socio-economic and behavioral data.
    
    Behavioral Insight from Monitor:
    - High education neighborhoods (Zuid, Centrum) eat 52% plant protein
    - Low education neighborhoods eat 39% plant protein
    - This creates counter-intuitive pattern: wealthy areas have LOWER meat 
      consumption despite higher overall food expenditure
    
    Returns:
        pd.DataFrame: Neighborhood data with columns:
            - Neighborhood: District name
            - Population: Resident count (2024)
            - Avg_Income: Average household income (EUR/year)
            - High_Education_Pct: Fraction with bachelor degree or higher
    """
    return pd.DataFrame({
        'Neighborhood': ['Centrum', 'Zuid', 'West', 'Noord', 'Zuidoost', 'Nieuw-West', 'Oost'],
        'Population': [87000, 145000, 145000, 99000, 89000, 160000, 135000],
        'Avg_Income': [48000, 56000, 34000, 29000, 24000, 26000, 36000],
        'High_Education_Pct': [0.65, 0.70, 0.60, 0.40, 0.30, 0.35, 0.55] 
    })

# ==========================================
# 3. CORE ENGINE
# ==========================================
class Scope3Engine:
    """
    Advanced Scope 3 emissions calculator with behavioral modifiers.
    
    Features:
    - Composite beta calculation (volume + preference effects)
    - Multi-dimensional impact assessment (CO2, land, water)
    - Category-level aggregation for visualization
    - Spatial simulation with neighborhood-level modifiers
    
    Attributes:
        cfg (HybridModelConfig): Model configuration parameters
        factors (pd.DataFrame): Environmental impact factors database
    """
    
    def __init__(self, config):
        """
        Initialize the Scope3 calculation engine.
        
        Args:
            config (HybridModelConfig): Configuration object
        """
        self.cfg = config
        self.factors = load_impact_factors()

    def calculate_beta(self, row):
        """ 
        Calculate composite consumption scaling factors.
        
        The Amsterdam Monitor revealed that:
        1. Higher income = MORE total food volume (wealthier people waste more)
        2. Higher education = LESS meat proportion (behavioral preference)
        
        Returns THREE values:
        - volume_beta: Overall consumption scaling driven by income
        - meat_modifier: Meat consumption adjustment based on education
        - plant_modifier: Plant consumption adjustment based on education
        
        Args:
            row (pd.Series): Neighborhood data with Avg_Income and High_Education_Pct
            
        Returns:
            tuple: (volume_beta, meat_modifier, plant_modifier)
        """
        income_ratio = row['Avg_Income'] / self.cfg.NATIONAL_AVG_INCOME
        volume_beta = self.cfg.SCALING_C1 * np.exp(self.cfg.SCALING_C2 * income_ratio)
        
        # Education Modifier (Higher Edu = Less Meat)
        if row['High_Education_Pct'] > 0.5:
            meat_modifier = 0.85
            plant_modifier = 1.15
        else:
            meat_modifier = 1.1
            plant_modifier = 0.9
            
        return volume_beta, meat_modifier, plant_modifier

    def calculate_raw_impact(self, diet_profile):
        """ 
        Calculate total environmental impact for a given diet profile.
        
        Sums impacts across all food items, accounting for:
        - Consumption amounts (grams/day)
        - Production losses (waste factor)
        - Environmental impact factors (CO2, land, water)
        
        Args:
            diet_profile (dict): Food items and daily consumption (grams)
            
        Returns:
            dict: Total daily per-capita impacts (co2, land, water)
        """
        res = {'co2': 0, 'land': 0, 'water': 0}
        for food, grams in diet_profile.items():
            if food not in self.factors.index: continue
            kg_produced = (grams / 1000) * self.cfg.WASTE_FACTOR
            f = self.factors.loc[food]
            res['co2'] += kg_produced * f['co2']
            res['land'] += kg_produced * f['land']
            res['water'] += kg_produced * f['water']
        return res

    def aggregate_visual_data(self, diet_profile):
        """ 
        Aggregate food items into broader categories for visualization.
        
        Converts individual food items (Beef, Pork) into aggregated categories
        (Red Meat, Poultry) for clearer charts. Scales to city-wide annual emissions.
        
        Args:
            diet_profile (dict): Food items and daily consumption (grams)
            
        Returns:
            tuple: (mass_dict, co2_dict)
                - mass_dict: Consumption mass by category (grams/day)
                - co2_dict: Annual city emissions by category (tonnes CO2e/year)
        """
        agg_mass = {k: 0.0 for k in CAT_ORDER}
        agg_co2 = {k: 0.0 for k in CAT_ORDER}
        
        for food, grams in diet_profile.items():
            if food not in self.factors.index: continue
            category = VISUAL_MAPPING.get(food, 'Other')
            if category not in agg_mass: continue
            
            kg_consumed_yr = (grams / 1000) * 365
            kg_produced_yr = kg_consumed_yr * self.cfg.WASTE_FACTOR
            f = self.factors.loc[food]
            co2_tonnes = (kg_produced_yr * f['co2'] * self.cfg.POPULATION_TOTAL) / 1000
            
            agg_mass[category] += grams
            agg_co2[category] += co2_tonnes
        return agg_mass, agg_co2

    def run_spatial_simulation(self, neighborhoods, diet_profile):
        """ 
        Simulate emissions across neighborhoods with behavioral modifiers.
        
        Applies neighborhood-specific scaling factors based on income and education,
        then aggregates to total neighborhood emissions.
        
        Args:
            neighborhoods (pd.DataFrame): Neighborhood data
            diet_profile (dict): Base diet profile to scale
            
        Returns:
            pd.DataFrame: Results with neighborhood-level emissions and modifiers
        """
        base_impact = self.calculate_raw_impact(diet_profile)
        results = []
        for _, row in neighborhoods.iterrows():
            vol_beta, meat_mod, plant_mod = self.calculate_beta(row)
            local_scaling = (0.4 * meat_mod + 0.1 * plant_mod + 0.5 * 1.0) * vol_beta
            local_co2_per_capita = base_impact['co2'] * local_scaling
            total_tonnes = (local_co2_per_capita * 365 * row['Population']) / 1000
            
            results.append({
                'Neighborhood': row['Neighborhood'],
                'Population': row['Population'],
                'Total_CO2_Tonnes': total_tonnes
            })
        return pd.DataFrame(results)

# ==========================================
# 4. VISUALIZATION SUITE
# ==========================================
def run_full_analysis():
    """
    Execute complete food systems emissions analysis and visualization.
    
    Workflow:
    1. Initialize model and load data
    2. Calculate impacts for all 7 diet scenarios
    3. Generate multi-chart visualization suite:
       - Nexus analysis (CO2/Land/Water comparison)
       - All plates (mass composition comparison)
       - All donuts (emissions breakdown with totals)
       - Distance to goals (heatmap of reduction pathways)
       - Neighborhood hotspots (spatial distribution)
    4. Output master tonnage console report
    
    Creates output files and prints detailed statistics to console.
    """
    cfg = HybridModelConfig()
    engine = Scope3Engine(cfg)
    diets = load_diet_profiles()
    neighborhoods = load_neighborhood_data()
    
    # ---------------------------------------------------------
    # PART A: DATA PREPARATION
    # Calculate impacts and aggregate for visualization
    # ---------------------------------------------------------
    print("Calculating impacts for all diets...")
    results_mass = {}
    results_co2 = {}
    total_footprints = {}
    
    for name, profile in diets.items():
        mass, co2 = engine.aggregate_visual_data(profile)
        results_mass[name] = mass
        results_co2[name] = co2
        total_footprints[name] = sum(co2.values())

    # ---------------------------------------------------------
    # CHART 1: NEXUS COMPARISON
    # Multi-resource impact analysis (CO2, Land, Water)
    # Shows which diet is worst/best across each dimension
    # ---------------------------------------------------------
    print("Generating 1_Nexus_Analysis.png...")
    nexus_data = []
    for name, profile in diets.items():
        res = engine.calculate_raw_impact(profile)
        res['Diet'] = name
        nexus_data.append(res)
    df_nexus = pd.DataFrame(nexus_data).set_index('Diet').sort_values('co2', ascending=False)
    
    fig1, axes = plt.subplots(1, 3, figsize=(20, 6))
    df_nexus['co2'].plot(kind='bar', ax=axes[0], color='#E74C3C', title='Carbon Footprint (kg CO2e/day)')
    df_nexus['land'].plot(kind='bar', ax=axes[1], color='#2ECC71', title='Land Use (m2/day)')
    df_nexus['water'].plot(kind='bar', ax=axes[2], color='#3498DB', title='Water Use (L/day)')
    plt.tight_layout()
    plt.savefig('1_Nexus_Analysis.png')

    # ---------------------------------------------------------
    # NEW: Scope 1+2 vs Scope 3 Comparison & Shares
    # ---------------------------------------------------------
    print("Generating 6_Scope12_vs_Scope3.png and 7_Scope3_Share.png...")
    factors = load_impact_factors()
    results_scope12 = {}
    scope12_breakdown = {}  # Store base, waste, retail components
    
    for name, profile in diets.items():
        cat_totals = {cat: 0.0 for cat in CAT_ORDER}
        for item, grams_day in profile.items():
            if item not in factors.index:
                continue
            kg_day = grams_day / 1000.0
            kg_year_person = kg_day * 365.0
            scope12_intensity = factors.loc[item, 'scope12'] if 'scope12' in factors.columns else 0.0
            co2_scope12_person_year = kg_year_person * scope12_intensity
            cat = VISUAL_MAPPING.get(item, item)
            if cat in cat_totals:
                cat_totals[cat] += co2_scope12_person_year
            else:
                cat_totals[cat] = co2_scope12_person_year
        try:
            pop = cfg.POPULATION_TOTAL
        except AttributeError:
            pop = None
        if pop:
            for cat in cat_totals:
                cat_totals[cat] = (cat_totals[cat] * pop) / 1000.0
        
        # Calculate Scope 1+2 components: Base + Waste (11%) + Retail/Distribution (2.5%)
        base_s12 = sum(cat_totals.values())
        waste_s12 = base_s12 * 0.11  # Food waste (household + processing)
        retail_s12 = base_s12 * 0.025  # Retail/distribution (cold chain + urban logistics)
        total_s12 = base_s12 + waste_s12 + retail_s12
        
        # Store breakdown for transparency
        scope12_breakdown[name] = {
            'base': base_s12,
            'waste': waste_s12,
            'retail': retail_s12,
            'total': total_s12
        }
        
        # Scale category totals to include waste + retail proportionally
        scaling_factor = total_s12 / base_s12 if base_s12 > 0 else 1.0
        for cat in cat_totals:
            cat_totals[cat] *= scaling_factor
        
        results_scope12[name] = cat_totals

    scope3_totals = {diet: sum(results_co2.get(diet, {}).values()) for diet in results_co2}
    scope12_totals = {diet: sum(results_scope12.get(diet, {}).values()) for diet in results_scope12}
    total_totals = {diet: scope12_totals.get(diet, 0.0) + scope3_totals.get(diet, 0.0) for diet in results_co2}
    
    df_compare = pd.DataFrame({
        'Scope 1+2': pd.Series(scope12_totals),
        'Scope 3': pd.Series(scope3_totals),
        'Total': pd.Series(total_totals)
    }).fillna(0.0)

    ax6 = df_compare.plot(kind='bar', figsize=(14, 8), color=['#7f8c8d', '#e67e22', '#2c3e50'])
    ax6.set_title('Scope 1+2, Scope 3, and Total Food Emissions by Diet (Tonnes CO2e/Year)')
    ax6.set_ylabel('Tonnes CO2e / Year')
    plt.xticks(rotation=15, ha='right')
    plt.tight_layout()
    plt.savefig('6_Scope12_vs_Scope3_Total.png')

    total_emissions = df_compare['Total']
    share_s12 = (df_compare['Scope 1+2'] / total_emissions).replace([np.inf, np.nan], 0.0) * 100.0
    share_s3 = (df_compare['Scope 3'] / total_emissions).replace([np.inf, np.nan], 0.0) * 100.0
    
    fig7, ax7 = plt.subplots(figsize=(14, 6))
    x = np.arange(len(share_s12))
    ax7.bar(x, share_s12, label='Scope 1+2', color='#7f8c8d', width=0.4)
    ax7.bar(x, share_s3, bottom=share_s12, label='Scope 3', color='#e67e22', width=0.4)
    ax7.set_title('Share of Scope 1+2 and Scope 3 in Total Food CO2')
    ax7.set_ylabel('% of Total Emissions')
    ax7.set_xticks(x)
    ax7.set_xticklabels(df_compare.index, rotation=15, ha='right')
    ax7.legend()
    plt.tight_layout()
    plt.savefig('7_Scope_Shares.png')

    print("Generating 8_All_Total_Emissions_Donuts.png...")
    results_total = {}
    for name, profile in diets.items():
        cat_totals = {cat: 0.0 for cat in CAT_ORDER}
        for item, grams_day in profile.items():
            if item not in factors.index:
                continue
            kg_day = grams_day / 1000.0
            kg_year_person = kg_day * 365.0
            scope3_intensity = factors.loc[item, 'co2'] if 'co2' in factors.columns else 0.0
            scope12_intensity = factors.loc[item, 'scope12'] if 'scope12' in factors.columns else 0.0
            total_intensity = scope3_intensity + scope12_intensity
            co2_total_person_year = kg_year_person * total_intensity
            cat = VISUAL_MAPPING.get(item, item)
            if cat in cat_totals:
                cat_totals[cat] += co2_total_person_year
            else:
                cat_totals[cat] = co2_total_person_year
        try:
            pop = cfg.POPULATION_TOTAL
        except AttributeError:
            pop = None
        if pop:
            for cat in cat_totals:
                cat_totals[cat] = (cat_totals[cat] * pop) / 1000.0
        results_total[name] = cat_totals

    n_diets8 = len(results_total)
    cols8 = int(np.ceil(np.sqrt(n_diets8)))
    rows8 = int(np.ceil(n_diets8 / cols8))
    fig8, axes8 = plt.subplots(rows8, cols8, figsize=(6 * cols8, 6 * rows8))
    axes8 = np.array(axes8).reshape(-1)
    
    for i, (name, total_dict) in enumerate(results_total.items()):
        if i >= len(axes8): break
        ax = axes8[i]
        vals = [total_dict[c] for c in CAT_ORDER]
        ax.pie(vals, labels=None, autopct='%1.0f%%', startangle=90, pctdistance=0.85, colors=COLORS)
        ax.set_title(name, fontsize=12, fontweight='bold')
        ax.add_artist(plt.Circle((0,0),0.65,fc='white'))
        total_t = sum(vals)
        ax.text(0, 0, f"{int(total_t/1000)}k\\nTonnes\\n(1+2+3)", ha='center', va='center', fontsize=9, fontweight='bold')
    
    for j in range(n_diets8, len(axes8)): axes8[j].axis('off')
    fig8.legend(CAT_ORDER, loc='lower center', ncol=8)
    plt.suptitle('Total Emissions (Scope 1+2+3) by Category', fontsize=16, fontweight='bold', y=0.995)
    plt.savefig('8_All_Total_Emissions_Donuts.png')

    print("\nScope 1+2 vs Scope 3 vs Total Summary (Tonnes CO2e/Year):")
    print("=" * 90)
    print(f"{'Diet':<30} {'Scope 1+2':<15} {'Scope 3':<15} {'Total (1+2+3)':<15}")
    print("-" * 90)
    for diet_name in df_compare.index:
        s12 = df_compare.loc[diet_name, 'Scope 1+2']
        s3 = df_compare.loc[diet_name, 'Scope 3']
        tot = df_compare.loc[diet_name, 'Total']
        print(f"{diet_name:<30} {int(s12):>13,} {int(s3):>13,} {int(tot):>13,}")
    print("=" * 90)
    
    # Print Scope 1+2 breakdown for transparency (Monitor 2024 diet only)
    if 'Monitor 2024' in scope12_breakdown:
        print("\nScope 1+2 Breakdown - Monitor 2024 Diet (Tonnes CO2e/Year):")
        print("=" * 90)
        bd = scope12_breakdown['Monitor 2024']
        print(f"  Base food consumption:          {int(bd['base']):>13,} tonnes ({bd['base']/bd['total']*100:.1f}%)")
        print(f"  + Food waste (11%):             {int(bd['waste']):>13,} tonnes ({bd['waste']/bd['total']*100:.1f}%)")
        print(f"  + Retail/distribution (2.5%):   {int(bd['retail']):>13,} tonnes ({bd['retail']/bd['total']*100:.1f}%)")
        print("-" * 90)
        print(f"  TOTAL Scope 1+2:                {int(bd['total']):>13,} tonnes (100.0%)")
        print("=" * 90)
        print(f"  Monitor 2024 target: 1,750,000 tonnes")
        error_pct = (bd['total'] - 1750000) / 1750000 * 100
        print(f"  Difference: {error_pct:+.2f}%")
        print("=" * 90)

    # ---------------------------------------------------------
    # CHART 2: THE PLATES
    # Physical mass composition of each diet
    # Shows what people actually eat (grams/day breakdown)
    # ---------------------------------------------------------
    print("Generating 2_All_Plates_Mass.png...")
    n_diets = len(results_mass)
    cols2 = int(np.ceil(np.sqrt(n_diets)))
    rows2 = int(np.ceil(n_diets / cols2))
    fig2, axes2 = plt.subplots(rows2, cols2, figsize=(6 * cols2, 6 * rows2))
    axes2 = np.array(axes2).reshape(-1)
    
    for i, (name, mass_dict) in enumerate(results_mass.items()):
        if i >= len(axes2): break
        ax = axes2[i]
        vals = [mass_dict[c] for c in CAT_ORDER]
        ax.pie(vals, labels=None, autopct='%1.0f%%', startangle=90, pctdistance=0.85, colors=COLORS)
        ax.set_title(name, fontsize=12, fontweight='bold')
        ax.add_artist(plt.Circle((0,0),0.65,fc='white'))
        ax.text(0, 0, "MASS", ha='center', va='center', fontsize=10, color='gray')

    # Hide unused subplots
    for j in range(n_diets, len(axes2)): axes2[j].axis('off')
    
    fig2.legend(CAT_ORDER, loc='lower center', ncol=8, bbox_to_anchor=(0.5, 0.02))
    plt.suptitle("The Plate: Physical Composition (Grams) Across Diets", fontsize=20, fontweight='bold', y=0.95)
    plt.savefig('2_All_Plates_Mass.png')

    # ---------------------------------------------------------
    # CHART 3: THE EMISSIONS
    # Emission breakdown by food category for each diet
    # Shows which categories are highest impact within each scenario
    # Total emissions displayed in center of each donut
    # ---------------------------------------------------------
    print("Generating 3_All_Emissions_Donuts.png...")
    n_diets3 = len(results_co2)
    cols3 = int(np.ceil(np.sqrt(n_diets3)))
    rows3 = int(np.ceil(n_diets3 / cols3))
    fig3, axes3 = plt.subplots(rows3, cols3, figsize=(6 * cols3, 6 * rows3))
    axes3 = np.array(axes3).reshape(-1)
    
    for i, (name, co2_dict) in enumerate(results_co2.items()):
        if i >= len(axes3): break
        ax = axes3[i]
        vals = [co2_dict[c] for c in CAT_ORDER]
        ax.pie(vals, labels=None, autopct='%1.0f%%', startangle=90, pctdistance=0.85, colors=COLORS)
        ax.set_title(name, fontsize=12, fontweight='bold')
        ax.add_artist(plt.Circle((0,0),0.65,fc='white'))
        
        # Add Total Tonnage in center
        total_t = sum(vals)
        ax.text(0, 0, f"{int(total_t/1000)}k\nTonnes", ha='center', va='center', fontsize=10, fontweight='bold')

    for j in range(n_diets3, len(axes3)): axes3[j].axis('off')
    
    fig3.legend(CAT_ORDER, loc='lower center', ncol=8, bbox_to_anchor=(0.5, 0.02))
    plt.suptitle("The Footprint: Emission Sources (CO2e) Across Diets", fontsize=20, fontweight='bold', y=0.95)
    plt.savefig('3_All_Emissions_Donuts.png')

    # ---------------------------------------------------------
    # CHART 4A: DISTANCE TO GOALS (PERCENTAGE)
    # Heatmap showing % emission reduction needed to reach each goal
    # Rows = Current states (what we eat now)
    # Columns = Policy targets (what we want to achieve)
    # Values = % reduction in total emissions needed
    # 
    # Example: 30% means current diet emits 30% MORE than target
    # → Need to CUT emissions by 30% to reach that goal
    # Higher % = Greater dietary transformation required
    # ---------------------------------------------------------
    print("Generating 4a_Distance_To_Goals_Percentage.png...")
    
    goals = ['5. Dutch Goal (60:40)', '6. Amsterdam Goal (70:30)', '7. EAT-Lancet (Planetary)']
    baselines = ['1. Monitor 2024 (Current)', '3. Metropolitan (High Risk)', '4. Metabolic Balance']
    
    data_matrix = []
    for base in baselines:
        row = []
        base_val = total_footprints[base]
        for goal in goals:
            goal_val = total_footprints[goal]
            reduction_needed = (base_val - goal_val) / base_val * 100
            row.append(reduction_needed)
        data_matrix.append(row)
    
    df_matrix = pd.DataFrame(data_matrix, index=baselines, columns=goals)
    
    fig4a, ax4a = plt.subplots(figsize=(12, 7))
    sns.heatmap(df_matrix, annot=True, fmt=".1f", cmap="Reds", cbar_kws={'label': '% Reduction Needed'}, ax=ax4a)
    ax4a.set_title("Distance to Target: % Emission Reduction Required\n(How much must current diets change to reach policy goals?)", 
                   fontsize=14, fontweight='bold', pad=20)
    ax4a.set_ylabel("Current Diet Pattern (Baseline)", fontsize=11, fontweight='bold')
    ax4a.set_xlabel("Policy Target (Goal)", fontsize=11, fontweight='bold')
    
    # Add explanation text
    fig4a.text(0.5, 0.02, 
               "Note: Values show % reduction in total food emissions needed. Example: 30% means current diet must CUT emissions by 30% to reach target.",
               ha='center', fontsize=9, style='italic', wrap=True)
    
    plt.tight_layout()
    plt.savefig('4a_Distance_To_Goals_Percentage.png')
    
    # ---------------------------------------------------------
    # CHART 4B: DISTANCE TO GOALS (ABSOLUTE CO2)
    # Heatmap showing absolute CO2 reduction needed (tonnes/year)
    # Shows the actual tonnage that must be eliminated from Amsterdam's food system
    # Higher values = More tonnes of CO2e that need to be cut
    # ---------------------------------------------------------
    print("Generating 4b_Distance_To_Goals_CO2_Tonnes.png...")
    
    data_matrix_co2 = []
    for base in baselines:
        row = []
        base_val = total_footprints[base]
        for goal in goals:
            goal_val = total_footprints[goal]
            reduction_tonnes = (base_val - goal_val) / 1000  # Convert to thousands of tonnes
            row.append(reduction_tonnes)
        data_matrix_co2.append(row)
    
    df_matrix_co2 = pd.DataFrame(data_matrix_co2, index=baselines, columns=goals)
    
    fig4b, ax4b = plt.subplots(figsize=(12, 7))
    sns.heatmap(df_matrix_co2, annot=True, fmt=".0f", cmap="YlOrRd", 
                cbar_kws={'label': 'CO2e Reduction (k Tonnes/Year)'}, ax=ax4b)
    ax4b.set_title("Distance to Target: Absolute CO2e Reduction Required\n(How many tonnes of emissions must Amsterdam eliminate?)", 
                   fontsize=14, fontweight='bold', pad=20)
    ax4b.set_ylabel("Current Diet Pattern (Baseline)", fontsize=11, fontweight='bold')
    ax4b.set_xlabel("Policy Target (Goal)", fontsize=11, fontweight='bold')
    
    # Add explanation text
    fig4b.text(0.5, 0.02, 
               "Note: Values show thousands of tonnes of CO2e per year that must be cut. Example: 240k tonnes ≈ emissions from 50,000 cars/year.",
               ha='center', fontsize=9, style='italic', wrap=True)
    
    plt.tight_layout()
    plt.savefig('4b_Distance_To_Goals_CO2_Tonnes.png')

    # ---------------------------------------------------------
    # ---------------------------------------------------------
    # CHART 9: SHARE IN CO2 VS SHARE IN CONSUMPTION (Monitor Figure 5 Style)
    # For each diet, compare % contribution to total CO2 vs % contribution to total mass
    # ---------------------------------------------------------
    print("Generating 9_CO2_vs_Mass_Share.png...")
    
    # Calculate for key diets
    comparison_diets = ['1. Monitor 2024 (Current)', '5. Dutch Goal (60:40)', '6. Amsterdam Goal (70:30)']
    
    fig9, axes = plt.subplots(1, len(comparison_diets), figsize=(20, 8))
    if len(comparison_diets) == 1:
        axes = [axes]
    
    for idx, diet_name in enumerate(comparison_diets):
        ax = axes[idx]
        
        # Get total mass and CO2
        mass_data = results_mass[diet_name]
        co2_data = results_co2[diet_name]
        
        total_mass = sum(mass_data.values())
        total_co2 = sum(co2_data.values())
        
        # Calculate percentages
        mass_pct = {cat: (mass_data[cat] / total_mass * 100) for cat in CAT_ORDER}
        co2_pct = {cat: (co2_data[cat] / total_co2 * 100) for cat in CAT_ORDER}
        
        # Sort by CO2 contribution
        sorted_cats = sorted(CAT_ORDER, key=lambda c: co2_pct[c], reverse=True)
        
        y_pos = np.arange(len(sorted_cats))
        width = 0.35
        
        bars1 = ax.barh(y_pos - width/2, [co2_pct[c] for c in sorted_cats], width, 
                        label='Share in CO2 emissions', color='#E74C3C', alpha=0.8)
        bars2 = ax.barh(y_pos + width/2, [mass_pct[c] for c in sorted_cats], width,
                        label='Share in consumption (mass)', color='#3498DB', alpha=0.8)
        
        ax.set_yticks(y_pos)
        ax.set_yticklabels(sorted_cats, fontsize=10)
        ax.set_xlabel('Percentage (%)', fontsize=11, fontweight='bold')
        ax.set_title(diet_name.split('(')[0].strip(), fontsize=12, fontweight='bold')
        ax.legend(loc='lower right', fontsize=9)
        ax.grid(axis='x', alpha=0.3, linestyle='--')
        ax.axvline(x=0, color='black', linewidth=0.8)
        
        # Add percentage labels
        for bar in bars1:
            width_val = bar.get_width()
            if width_val > 1:
                ax.text(width_val, bar.get_y() + bar.get_height()/2, f'{width_val:.1f}%',
                       ha='left', va='center', fontsize=8, color='#E74C3C', fontweight='bold')
    
    plt.tight_layout()
    plt.savefig('9_CO2_vs_Mass_Share.png', dpi=300, bbox_inches='tight')
    plt.close()
    
    # ---------------------------------------------------------
    # CHART 10: ENVIRONMENTAL IMPACT BY FOOD TYPE (Monitor Figure 4 Style)
    # Breakdown by plant-based, animal, mixed (dairy/eggs), processed
    # ---------------------------------------------------------
    print("Generating 10_Impact_by_Food_Type.png...")
    
    # Define food type categories
    FOOD_TYPE_MAP = {
        'Red Meat': 'Animal', 'Poultry': 'Animal', 'Fish': 'Animal',
        'Dairy & Eggs': 'Mixed (Dairy/Eggs)',
        'Plant Protein': 'Plant-based', 'Veg & Fruit': 'Plant-based', 'Staples': 'Plant-based',
        'Ultra-Processed': 'Processed',
        'Beverages & Additions': 'Processed',
        'Oils & Condiments': 'Processed'
    }
    
    fig10, axes = plt.subplots(2, 2, figsize=(16, 12))
    axes = axes.flatten()
    
    comparison_diets_4 = ['1. Monitor 2024 (Current)', '5. Dutch Goal (60:40)', 
                          '6. Amsterdam Goal (70:30)', '7. EAT-Lancet (Planetary)']
    
    for idx, diet_name in enumerate(comparison_diets_4):
        ax = axes[idx]
        
        # Aggregate by food type
        type_totals = {'Plant-based': 0, 'Animal': 0, 'Mixed (Dairy/Eggs)': 0, 'Processed': 0}
        for cat in CAT_ORDER:
            food_type = FOOD_TYPE_MAP[cat]
            type_totals[food_type] += results_co2[diet_name][cat]
        
        total = sum(type_totals.values())
        type_pct = {k: (v/total*100) for k, v in type_totals.items()}
        
        # Create stacked bar
        categories = ['Climate\nChange', 'Land Use', 'Water Use']
        plant_vals = [type_pct['Plant-based']] * 3
        animal_vals = [type_pct['Animal']] * 3
        mixed_vals = [type_pct['Mixed (Dairy/Eggs)']] * 3
        processed_vals = [type_pct['Processed']] * 3
        
        x = np.arange(len(categories))
        width = 0.6
        
        p1 = ax.bar(x, plant_vals, width, label='Plant-based', color='#2ECC71')
        p2 = ax.bar(x, animal_vals, width, bottom=plant_vals, label='Animal', color='#E74C3C')
        p3 = ax.bar(x, mixed_vals, width, bottom=np.array(plant_vals)+np.array(animal_vals), 
                    label='Mixed (Dairy/Eggs)', color='#F39C12')
        p4 = ax.bar(x, processed_vals, width, 
                    bottom=np.array(plant_vals)+np.array(animal_vals)+np.array(mixed_vals),
                    label='Processed', color='#95A5A6')
        
        ax.set_ylabel('Percentage (%)', fontsize=11, fontweight='bold')
        ax.set_title(diet_name.split('(')[0].strip(), fontsize=12, fontweight='bold')
        ax.set_xticks(x)
        ax.set_xticklabels(categories, fontsize=10)
        ax.set_ylim(0, 100)
        ax.legend(loc='upper right', fontsize=9)
        ax.grid(axis='y', alpha=0.3, linestyle='--')
        
        # Add percentage labels
        for i, rect in enumerate(p1):
            height = rect.get_height()
            if height > 3:
                ax.text(rect.get_x() + rect.get_width()/2., height/2,
                       f'{height:.0f}%', ha='center', va='center', fontsize=9, fontweight='bold')
        
        for i, rect in enumerate(p2):
            height = rect.get_height()
            bottom = plant_vals[i]
            if height > 3:
                ax.text(rect.get_x() + rect.get_width()/2., bottom + height/2,
                       f'{height:.0f}%', ha='center', va='center', fontsize=9, fontweight='bold')
    
    plt.tight_layout()
    plt.savefig('10_Impact_by_Food_Type.png', dpi=300, bbox_inches='tight')
    plt.close()
    
    # ---------------------------------------------------------
    # CHART 11: CONSUMPTION VS PROTEIN CONTRIBUTION (Monitor Figure 2 Style)
    # Compare mass share vs protein share for each food category
    # ---------------------------------------------------------
    print("Generating 11_Mass_vs_Protein.png...")
    
    # Protein content per kg (approximate values)
    PROTEIN_CONTENT = {
        'Red Meat': 0.20, 'Poultry': 0.25, 'Fish': 0.20, 'Dairy & Eggs': 0.12,
        'Plant Protein': 0.20, 'Staples': 0.10, 'Veg & Fruit': 0.02, 'Ultra-Processed': 0.05,
        'Beverages & Additions': 0.01,
        'Oils & Condiments': 0.01
    }
    
    fig11, axes = plt.subplots(1, len(comparison_diets), figsize=(20, 8))
    if len(comparison_diets) == 1:
        axes = [axes]
    
    for idx, diet_name in enumerate(comparison_diets):
        ax = axes[idx]
        
        mass_data = results_mass[diet_name]
        total_mass = sum(mass_data.values())
        
        # Calculate protein contribution
        protein_data = {cat: mass_data[cat] * PROTEIN_CONTENT[cat] for cat in CAT_ORDER}
        total_protein = sum(protein_data.values())
        
        # Calculate percentages
        mass_pct = {cat: (mass_data[cat] / total_mass * 100) for cat in CAT_ORDER}
        protein_pct = {cat: (protein_data[cat] / total_protein * 100) for cat in CAT_ORDER}
        
        # Sort by protein contribution
        sorted_cats = sorted(CAT_ORDER, key=lambda c: protein_pct[c], reverse=True)
        
        y_pos = np.arange(len(sorted_cats))
        width = 0.35
        
        bars1 = ax.barh(y_pos - width/2, [mass_pct[c] for c in sorted_cats], width,
                        label='Share in consumption (mass)', color='#3498DB', alpha=0.8)
        bars2 = ax.barh(y_pos + width/2, [protein_pct[c] for c in sorted_cats], width,
                        label='Share in protein intake', color='#2ECC71', alpha=0.8)
        
        ax.set_yticks(y_pos)
        ax.set_yticklabels(sorted_cats, fontsize=10)
        ax.set_xlabel('Percentage (%)', fontsize=11, fontweight='bold')
        ax.set_title(diet_name.split('(')[0].strip(), fontsize=12, fontweight='bold')
        ax.legend(loc='lower right', fontsize=9)
        ax.grid(axis='x', alpha=0.3, linestyle='--')
        ax.axvline(x=0, color='black', linewidth=0.8)
        
        # Calculate plant vs animal protein
        plant_protein = sum([protein_data[c] for c in ['Plant Protein', 'Staples', 'Veg & Fruit']])
        animal_protein = sum([protein_data[c] for c in ['Red Meat', 'Poultry', 'Fish', 'Dairy & Eggs']])
        plant_pct_total = plant_protein / (plant_protein + animal_protein) * 100
        
        ax.text(0.98, 0.98, f'Plant protein: {plant_pct_total:.0f}%\nAnimal protein: {100-plant_pct_total:.0f}%',
               transform=ax.transAxes, ha='right', va='top', fontsize=10, 
               bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
    
    plt.tight_layout()
    plt.savefig('11_Mass_vs_Protein.png', dpi=300, bbox_inches='tight')
    plt.close()
    
    # ---------------------------------------------------------
    # CHART 12: INTAKE VS REFERENCE LEVELS (Monitor Last Figure Style)
    # Compare dietary intake against reference guidelines (Schijf van 5)
    # ---------------------------------------------------------
    print("Generating 12_Intake_vs_Reference.png...")
    
    # Use Schijf van 5 as reference
    reference_diet = '8. Schijf van 5 (Guideline)'
    comparison_diets_ref = ['1. Monitor 2024 (Current)', '3. Metropolitan (High Risk)',
                            '5. Dutch Goal (60:40)', '6. Amsterdam Goal (70:30)', '7. EAT-Lancet (Planetary)']
    
    fig12, ax = plt.subplots(figsize=(14, 10))
    
    ref_mass = results_mass[reference_diet]
    
    # Sort categories by reference intake
    sorted_cats = sorted(CAT_ORDER, key=lambda c: ref_mass[c], reverse=True)
    y_pos = np.arange(len(sorted_cats))
    
    # Calculate percentage of reference for each diet
    width = 0.15
    colors_diets = ['#3498DB', '#E74C3C', '#F39C12', '#2ECC71', '#9B59B6']
    
    for idx, diet_name in enumerate(comparison_diets_ref):
        diet_mass = results_mass[diet_name]
        pct_of_ref = [(diet_mass[cat] / ref_mass[cat] * 100) if ref_mass[cat] > 0 else 0 
                      for cat in sorted_cats]
        
        offset = (idx - len(comparison_diets_ref)/2 + 0.5) * width
        bars = ax.barh(y_pos + offset, pct_of_ref, width,
                       label=diet_name.split('(')[0].strip()[:20], 
                       color=colors_diets[idx], alpha=0.8)
    
    ax.set_yticks(y_pos)
    ax.set_yticklabels(sorted_cats, fontsize=11)
    ax.set_xlabel('2024 dietary intake versus reference intake (%)', fontsize=12, fontweight='bold')
    ax.set_title('Dietary Intake Comparison Against Schijf van 5 Reference', 
                 fontsize=14, fontweight='bold', pad=20)
    ax.axvline(x=100, color='black', linewidth=2, linestyle='--', label='Reference (100%)')
    ax.legend(loc='lower right', fontsize=9, ncol=2)
    ax.grid(axis='x', alpha=0.3, linestyle='--')
    ax.set_xlim(0, 250)
    
    plt.tight_layout()
    plt.savefig('12_Intake_vs_Reference.png', dpi=300, bbox_inches='tight')
    plt.close()
    
    # CONSOLE REPORT: MASTER TONNAGE TABLE
    # Detailed breakdown of emissions by food category
    # Shows absolute values (tonnes/year) and % change from baseline
    # ---------------------------------------------------------
    print("\n" + "="*80)
    print(f"{'MASTER SCOPE 3 TONNAGE REPORT':^80}")
    print("="*80)
    
    diet_names = list(diets.keys())
    short_map = {
        '1. Monitor 2024 (Current)': '1.Monitor',
        '2. Amsterdam Theoretical': '2.Theory',
        '3. Metropolitan (High Risk)': '3.Metro',
        '4. Metabolic Balance': '4.Meta',
        '5. Dutch Goal (60:40)': '5.DuGoal',
        '6. Amsterdam Goal (70:30)': '6.AmGoal',
        '7. EAT-Lancet (Planetary)': '7.EAT',
        '8. Schijf van 5 (Guideline)': '8.Schijf',
        '9. Mediterranean Diet': '9.Med'
    }
    short_names = [short_map.get(n, n) for n in diet_names]
    row_fmt = "{:<22}" + "{:>12}" * len(short_names)
    print(row_fmt.format("CATEGORY", *short_names))
    print("-" * 120)
    
    for cat in CAT_ORDER:
        vals = [results_co2[d][cat] for d in diet_names]
        f_vals = [f"{v:,.0f}" for v in vals]
        print(row_fmt.format(cat, *f_vals))
        
    print("-" * 120)
    totals = [sum(results_co2[d].values()) for d in diet_names]
    f_totals = [f"{t:,.0f}" for t in totals]
    print(row_fmt.format("TOTAL (Tonnes)", *f_totals))
    print("="*80)

if __name__ == "__main__":
    """
    Main execution block.
    
    Runs the complete food systems emissions analysis:
    - Initializes model configuration and engine
    - Loads all data (diets, neighborhoods, impact factors)
    - Generates 4 visualization files
    - Prints master tonnage report to console
    """
    run_full_analysis()